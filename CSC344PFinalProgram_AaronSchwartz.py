import random

def createNodes(b, n):
    """ 
    creates a list of n random nodes, based off of the possible size 2^b bits
  
    Parameters: 
    b (int): the size 2^b of the CHORD system
    n (int): the number of nodes to be created
  
    Returns: 
    nodes[]: a list of numbers that symbolize the nodes within the CHORD system  
  
    """
    total = 2 ** b
    nodes = []
    for i in range(n):
        valid_node = False
        while not valid_node:
            new_node = random.randrange(1, total)
            if new_node not in nodes:
                nodes.append(new_node)
                valid_node = True
    nodes.sort()
##    for i in range(len(nodes)):
##        nodes[i] = "N" + str(nodes[i])
    return nodes


def createFingerTables(b, nodes):
    """ 
    Creates a finger table for each node within the input nodes and stores it within a dictionary.
    The finger table itself is a dictionary with a string as the key "N(node number) + 2(finger)"
    and the value being the resulting node. This allows for neat printout of finger tables later.
  
    Parameters: 
    b (int): the size 2^b of the CHORD system
    nodes[]: a list of all the nodes within the system
  
    Returns: 
    finger_tables{}: a dictionary consisting of the nodes as keys and the finger table dictionaries
        as values.

        If the nodes are [1, 15, 21, 23, 28], the return will look like this:
        {1:{2:15, 3:15, 5:15, 9:15, 17:21},
         15:{16:21, 17:21, 19:21, 23:23, 31:1},
         ...}
         
    """
    FT = {}
    for j in nodes:
        newnodes = []
        for k in range(b):
            tempnewnode = j + (2**k)
            
            while tempnewnode > (2**b):
                tempnewnode -= (2**b)
            newnodes.append(tempnewnode)
        #print(newnodes)

        newNodeFT = {}
        for nnode in newnodes:
            correctNode = None
            if nnode > nodes[len(nodes) - 1] and nnode <= (2**b):
                correctNode = nodes[0]
            elif nnode < nodes[0]:
                correctNode = nodes[0]
            currentNodeIndex = 0
            for node in nodes:
                if correctNode is not None:
                    break
                if currentNodeIndex + 1 == len(nodes):
                    nextNode = nodes[0]
                else:
                    nextNode = nodes[currentNodeIndex + 1]
                if nnode == node:
                    correctNode = node
                    break
                elif nnode > node:
                    if nnode < nextNode:
                        correctNode = nextNode
                        break
                currentNodeIndex += 1
            #print(nnode, correctNode)
            newNodeFT[nnode] = correctNode
        FT[j] = newNodeFT
##    for key in FT:
##        print('{}  |  {}'.format(key, FT[key]))
    return FT   
            

def findVisitingOrder(destKey, nodes, FT, b):
    """ 
    Finds the visiting order from a dictionary of finger tables (generated by createFingerTables) from
    the provided starting node to the node that contains the key provided.
  
    Parameters: 
    destKey (int): the key to locate in the CHORD system
    nodes[]: a list of all the nodes within the system
    FT{}: a dictionary containing the finger tables of every node in the system. It is assumed that
        the dictionary was created using createFingerTables. Modifying the output of createFingerTables
        will render this function unusable.
    b (int): the size 2^b of the CHORD system
  
    Returns: 
    VO[]: a list containing the nodes that are visited using the CHORD system to find the node that contains
        the requested key.
    
    """
    nStart= nodes[1]
    VO = [nStart]
    currentPos = nStart
    if destKey > nodes[len(nodes) - 1] or destKey <= nodes[0]:
        destination = nodes[0]
    else:
        currentNodeIndex = 0
        for node in nodes:
            if currentNodeIndex + 1 == len(nodes):
                nextNode = nodes[0]
            else:
                nextNode = nodes[currentNodeIndex + 1]
            if destKey > node:
                if destKey <= nextNode:
                    destination = nextNode
                    break
            currentNodeIndex += 1
    destinationFound = (currentPos == destination)
    #print('The destination is {} and has it been found? {}'.format(destination, destinationFound))
    #print(currentPos)
    while not destinationFound:
        minDiff = 100000000
        numofgreater = 0
        prev = None
        for key in FT[currentPos]:
            if FT[currentPos][key] > destination:
                if prev != None:
                    if prev > FT[currentPos][key]:
                        nextkey = prev
                        break
                numofgreater += 1
                if numofgreater == b:
                    nextkey = key
                prev = key
            else:
                diff = destination - FT[currentPos][key]
                if diff < minDiff:
                    minDiff = diff
                    nextkey = key
                prev = key
        #print(nextkey)
        currentPos = FT[currentPos][nextkey]
        #print(currentPos)
        VO.append(currentPos)
        destinationFound = (currentPos == destination)

    return VO


def printFingerTables(visitingOrder, FT, b):
    """ 
    Prints out the correct finger tables in an aesthetically pleasing way. Correct finger tables
    are determined from the visitingOrder list parameter.
  
    Parameters:
    visitingOrder[]: a list containing the visiting order of nodes
    FT{}: a dictionary containing the finger tables of every node in the system. It is assumed that
        the dictionary was created using createFingerTables. Modifying the output of createFingerTables
        will render this function unusable.
    b (int): the size 2^b of the CHORD system
  
    Returns: 
    None
    
    """
    for node in visitingOrder:
        if len(visitingOrder) == 1:
            print('No finger table necessary; we started at the destination!')
            break
        if node != visitingOrder[len(visitingOrder) - 1]:
            print('\nNODE {} FINGER TABLE:'.format(node))
            print('---------------------')
            for k in range(b):
                nextNode = node + 2**k
                while nextNode > 2**b:
                    nextNode -= 2**b
                if FT[node][nextNode] == visitingOrder[len(visitingOrder) - 1]:
                    print("N{} + {:<8}| N{} [destination]".format(node, 2**k, FT[node][nextNode]))
                else:
                    print("N{} + {:<8}| N{}".format(node, 2**k, FT[node][nextNode]))


def runProgram():
    print("Welcome to Aaron Schwartz's CHORD simulator!")
    print("This program will generate a CHORD system based on your input, as well as")
    print("generate a random key within that system and find it.")
    
    valid_input = False
    while not valid_input:
        b = input("Please enter the value of b (Circular ID-space with 'b'-bit) between 5 and 10: ")
        if b.isdigit():
            b = int(b)
        else:
            print("That was not an integer! Please try again.")
            continue
        if b < 5 or b > 10:
            print("The number must be between 5 and 10! Please try again.")
            continue
        valid_input = True
    
    valid_input = False
    while not valid_input:
        n = input("Please enter how many Nodes exist within this chord system between 5 and 15: ")
        if n.isdigit():
            n = int(n)
        else:
            print("That was not an integer! Please try again.")
            continue
        if n < 5 or n > 15:
            print("The number must be between 5 and 15! Please try again.")
            continue
        valid_input = True
    print("\nYou have created a CHORD system that consists of {} nodes within a Circular ID-space with {}-bits.".format(n, b))
    nodes = createNodes(b, n)
    nodeString = ""
    for a in range(len(nodes)):
        if a == len(nodes) - 1:
            nodeString += "and N" + str(nodes[a]) + "."
            break
        nodeString += "N" + str(nodes[a]) + ", "
    print('The randomly generated nodes within this CHORD system are: ' + nodeString)
    key = random.randrange(1, 2 ** b)
    print('The randomly generated key to find in this CHORD system is K' + str(key) + ".")
    nStart= nodes[1]
    print('\nWe will start from the second node in the system, in this case N' + str(nStart) + ".")
    
    
    fingerTables = createFingerTables(b, nodes)
    VO = findVisitingOrder(key, nodes, fingerTables, b)
    print('The node visiting order from nStart to the destination is:')
    y = ''
    vocount = 1
    for x in VO:
        if vocount == len(VO):
            y += 'N{}'.format(str(x)) + ' [destination]'
        else:
            y += 'N{}'.format(str(x)) + ' > '
        vocount += 1
    print(y)
    printFingerTables(VO, fingerTables, b)




def main():
    processing = True
    while processing:
        runProgram()
        keepProcess = input('\nWould you like to run another CHORD simulation? (type "YES" if so!): ')
        if keepProcess == "YES":
            print('\n\n\n')
            continue
        else:
            print("Thank you for using Aaron Schwartz's CHORD simulator! Please come again.")
            processing = False

main()
